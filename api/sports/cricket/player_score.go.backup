package cricket

import (
	"fmt"
	"khelogames/core/token"
	db "khelogames/database"
	"khelogames/database/models"
	"khelogames/pkg"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

func (s *CricketServer) UpdateCricketInningStatusFunc(ctx *gin.Context) {

	var req struct {
		MatchPublicID string `json:"match_public_id"`
		TeamPublicID  string `json:"team_public_id"`
		InningNumber  int    `json:"inning_number"`
	}

	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind: ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid request format",
		})
		return
	}

	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	teamPublicID, err := uuid.Parse(req.TeamPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "INTERNAL_ERROR",
			"message": "Failed to get match details",
		})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		s.logger.Error("Fai.ed to get user tournament role: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "INTERNAL_ERROR",
			"message": "Failed to get user tournament role",
		})
		return
	}
	if !isExists {
		s.logger.Error("Failed to verify user role for tournament: ", err)
		ctx.JSON(http.StatusForbidden, gin.H{
			"success": false,
			"code":    "FORBIDDEN_ERROR",
			"message": "You are not allowed to update inning status",
		})
		return
	}

	inningStatus, err := s.store.UpdateCricketInningsStatus(ctx, matchPublicID, teamPublicID, req.InningNumber)
	if err != nil {
		s.logger.Error("Failed to update inning status: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "INTERNAL_ERROR",
			"message": "Failed to update inning status",
		})
		return
	}

	var inningData map[string]interface{}
	inningData = map[string]interface{}{
		"id":                  inningStatus.ID,
		"public_id":           inningStatus.PublicID,
		"match_id":            inningStatus.MatchID,
		"team_id":             inningStatus.TeamID,
		"inning_number":       inningStatus.InningNumber,
		"score":               inningStatus.Score,
		"overs":               inningStatus.Overs,
		"inning_status":       inningStatus.InningStatus,
		"is_inning_completed": inningStatus.IsInningCompleted,
		"declared":            inningStatus.Declared,
		"follow_on":           inningStatus.FollowOn,
		"target_run_rate":     inningStatus.TargetRunRate,
		"run_rate":            inningStatus.RunRate,
	}

	ctx.JSON(http.StatusAccepted, inningStatus)
	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "INNING_STATUS", inningData)
		if err != nil {
			s.logger.Error("Failed to broadcast cricket event: ", err)
			ctx.JSON(http.StatusInternalServerError, gin.H{
				"success": false,
				"code":    "INTERNAL_ERROR",
				"message": "Failed to broadcast cricket event",
			})
			return
		}
	}

}

type addCricketBatScore struct {
	MatchPublicID      string `json:"match_public_id"`
	TeamPublicID       string `json:"team_public_id"`
	BatsmanPublicID    string `json:"batsman_public_id"`
	Position           string `json:"position"`
	RunsScored         int32  `json:"runs_scored"`
	BallsFaced         int32  `json:"balls_faced"`
	Fours              int32  `json:"fours"`
	Sixes              int32  `json:"sixes"`
	BattingStatus      bool   `json:"batting_status"`
	IsStriker          bool   `json:"is_striker"`
	IsCurrentlyBatting bool   `json:"is_currently_batting"`
	InningNumber       int    `json:"inning_number"`
}

func (s *CricketServer) AddCricketBatScoreFunc(ctx *gin.Context) {
	var req addCricketBatScore
	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind player batting score: ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid request format",
		})
		return
	}

	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid match UUID: ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid match ID format",
		})
		return
	}

	teamPublicID, err := uuid.Parse(req.TeamPublicID)
	if err != nil {
		s.logger.Error("Invalid team UUID: ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid team ID format",
		})
		return
	}

	batsmanPublicID, err := uuid.Parse(req.BatsmanPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman UUID: ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code":    "VALIDATION_ERROR",
			"message": "Invalid batsman ID format",
		})
		return
	}

	strickerResponse, err := s.store.GetCricketStricker(ctx, matchPublicID, teamPublicID, req.InningNumber)
	if err != nil {
		s.logger.Error("Failed to get striker: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "DATABASE_ERROR",
			"message": "An error occurred. Please try again later.",
		})
		return
	}

	arg := db.AddCricketBatsScoreParams{
		MatchPublicID:      matchPublicID,
		TeamPublicID:       teamPublicID,
		BatsmanPublicID:    batsmanPublicID,
		InningNumber:       req.InningNumber,
		Position:           req.Position,
		RunsScored:         req.RunsScored,
		BallsFaced:         req.BallsFaced,
		Fours:              req.Fours,
		Sixes:              req.Sixes,
		BattingStatus:      req.BattingStatus,
		IsStriker:          req.IsStriker,
		IsCurrentlyBatting: req.IsCurrentlyBatting,
	}

	if strickerResponse != nil {
		arg.IsStriker = false
	} else {
		arg.IsStriker = true
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		s.logger.Error("Tournament match not found: ", err)
		ctx.JSON(http.StatusNotFound, gin.H{
			"success": false,
			"code":    "NOT_FOUND",
			"message": "Tournament match not found",
		})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		s.logger.Error("Failed to check tournament role: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "DATABASE_ERROR",
			"message": "An error occurred. Please try again later.",
		})
		return
	}
	if !isExists {
		s.logger.Warn("Unauthorized access attempt to match: ", matchPublicID)
		ctx.JSON(http.StatusForbidden, gin.H{
			"success": false,
			"code":    "AUTHORIZATION_ERROR",
			"message": "You don't have permission to update this match",
		})
		return
	}

	response, err := s.store.AddCricketBatsScore(ctx, arg)
	if err != nil {
		s.logger.Error("Failed to add cricket batting score: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "DATABASE_ERROR",
			"message": "Failed to save batting score. Please try again.",
		})
		return
	}

	playerData, err := s.store.GetPlayerByPublicID(ctx, batsmanPublicID)
	if err != nil {
		s.logger.Error("Failed to get player data: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"code":    "DATABASE_ERROR",
			"message": "An error occurred. Please try again later.",
		})
		return
	}

	batsman := map[string]interface{}{
		"id":                   response.ID,
		"public_id":            response.PublicID,
		"player":               map[string]interface{}{"id": playerData.ID, "public_id": playerData.PublicID, "name": playerData.Name, "slug": playerData.Slug, "shortName": playerData.ShortName, "position": playerData.Positions},
		"team_id":              response.TeamID,
		"match_id":             response.MatchID,
		"batsman_id":           response.BatsmanID,
		"runsScored":           response.RunsScored,
		"ballFaced":            response.BallsFaced,
		"fours":                response.Fours,
		"sixes":                response.Sixes,
		"batting_status":       response.BattingStatus,
		"is_striker":           response.IsStriker,
		"is_currently_batting": response.IsCurrentlyBatting,
		"inning_number":        response.InningNumber,
	}

	ctx.JSON(http.StatusAccepted, batsman)
	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "ADD_BATSMAN", batsman)
		if err != nil {
			s.logger.Error("Failed to broadcast cricket event: ", err)
		}
	}
}

type addCricketBallScore struct {
	MatchPublicID      string `json:"match_public_id"`
	TeamPublicID       string `json:"team_public_id"`
	BowlerPublicID     string `json:"bowler_public_id"`
	PrevBowlerPublicID string `json:"prev_bowler_public_id"`
	BallNumber         int32  `json:"ball_number"`
	Runs               int32  `json:"runs"`
	Wickets            int32  `json:"wickets"`
	Wide               int32  `json:"wide"`
	NoBall             int32  `json:"no_ball"`
	InningNumber       int    `json:"inning_number"`
}

func (s *CricketServer) AddCricketBallFunc(ctx *gin.Context) {
	var req addCricketBallScore
	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	teamPublicID, err := uuid.Parse(req.TeamPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	bowlerPublicID, err := uuid.Parse(req.BowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	var prevBowlerPublicID uuid.UUID
	if req.PrevBowlerPublicID != "" {
		prevBowlerPublicID, err = uuid.Parse(req.PrevBowlerPublicID)
		if err != nil {
			s.logger.Error("Invalid UUID format", err)
			ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
			return
		}
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	var newBowlerResponse models.BowlerScore
	var prevBowler map[string]interface{}
	newBowlerResponse, prevBowler, err = s.txStore.AddCricketBlowerTx(ctx, matchPublicID, teamPublicID, bowlerPublicID, prevBowlerPublicID, req.InningNumber)
	if err != nil {
		s.logger.Error("Failed to add cricket bowler: ", err)
		return
	}

	playerData, err := s.store.GetPlayerByPublicID(ctx, bowlerPublicID)
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
	}

	currentBowler := map[string]interface{}{
		"player":            map[string]interface{}{"id": playerData.ID, "public_id": playerData.PublicID, "name": playerData.Name, "slug": playerData.Slug, "shortName": playerData.ShortName, "position": playerData.Positions},
		"id":                newBowlerResponse.ID,
		"public_id":         newBowlerResponse.PublicID,
		"match_id":          newBowlerResponse.MatchID,
		"team_id":           newBowlerResponse.TeamID,
		"bowler_id":         newBowlerResponse.BowlerID,
		"runs":              newBowlerResponse.Runs,
		"ball_number":       newBowlerResponse.BallNumber,
		"wide":              newBowlerResponse.Wide,
		"no_ball":           newBowlerResponse.NoBall,
		"wickets":           newBowlerResponse.Wickets,
		"bowling_status":    newBowlerResponse.BowlingStatus,
		"is_current_bowler": newBowlerResponse.IsCurrentBowler,
		"inning_number":     newBowlerResponse.InningNumber,
	}

	bowlerContent := map[string]interface{}{
		"current_bowler": prevBowler,
		"next_bowler":    currentBowler,
	}
	ctx.JSON(http.StatusAccepted, gin.H{
		"current_bowler": prevBowler,
		"next_bowler":    currentBowler,
	})

	if s.scoreBroadcaster != nil {
		s.scoreBroadcaster.BroadcastCricketEvent(ctx, "ADD_BOWLER", bowlerContent)
		if err != nil {
			s.logger.Error("Failed to broadcast cricket event: ", err)
		}
	}
}

func (s *CricketServer) GetPlayerScoreFunc(ctx *gin.Context) {

	matchPublicIDString := ctx.Query("match_public_id")
	teamPublicIDString := ctx.Query("team_public_id")
	gameName := ctx.Param("sport")
	matchPublicID, err := uuid.Parse(matchPublicIDString)
	if err != nil {
		s.logger.Error("Failed to parse match id ", err)
		return
	}

	teamPublicID, err := uuid.Parse(teamPublicIDString)
	if err != nil {
		s.logger.Error("Failed to parse team id ", err)
		return
	}

	game, err := s.store.GetGamebyName(ctx, gameName)
	if err != nil {
		s.logger.Error("Failed to get the game: ", gin.H{"error": err.Error()})
		return
	}

	teamPlayerScore, err := s.store.GetCricketPlayersScore(ctx, matchPublicID, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get players score : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if len(teamPlayerScore) == 0 {
		s.logger.Warn("No players score found for match and team")
		ctx.JSON(http.StatusOK, gin.H{
			"battingTeam": nil,
			"innings":     nil,
		})
		return
	}

	_, err = s.store.GetMatchByPublicId(ctx, matchPublicID, game.ID)
	if err != nil {
		s.logger.Error("Failed to get match:", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	playerOut, err := s.store.GetCricketWickets(ctx, matchPublicID, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get wicket: ", err)
		return
	}

	battingTeam, err := s.store.GetTeamByPublicID(ctx, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get batting team : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	}

	inningData := make(map[string][]map[string]interface{})
	for _, playerScore := range teamPlayerScore {
		playerData, err := s.store.GetPlayerByID(ctx, int64(playerScore.BatsmanID))
		if err != nil {
			s.logger.Error("Failed to get players data : ", err)
			ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		}
		playerDetails := map[string]interface{}{
			"player":               map[string]interface{}{"id": playerData.ID, "public_id": playerData.PublicID, "name": playerData.Name, "slug": playerData.Slug, "shortName": playerData.ShortName, "position": playerData.Positions},
			"id":                   playerScore.ID,
			"public_id":            playerData.PublicID,
			"match_id":             playerScore.MatchID,
			"team_id":              playerScore.TeamID,
			"batsman_id":           playerScore.BatsmanID,
			"runs_scored":          playerScore.RunsScored,
			"balls_faced":          playerScore.BallsFaced,
			"fours":                playerScore.Fours,
			"sixes":                playerScore.Sixes,
			"batting_status":       playerScore.BattingStatus,
			"is_striker":           playerScore.IsStriker,
			"is_currently_batting": playerScore.IsCurrentlyBatting,
			"inning_number":        playerScore.InningNumber,
		}

		for _, item := range playerOut {
			if int64(item.BatsmanID) == playerData.ID {
				bowlerData, err := s.store.GetPlayerByID(ctx, int64(item.BowlerID))
				if err != nil {
					s.logger.Error("Failed to get bowler data : ", err)
					ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
					return
				}
				// Add wicket details to the same playerDetails map
				playerDetails["wicket_type"] = item.WicketType
				playerDetails["bowler_name"] = bowlerData.Name
				break
			}
		}
		playerScoreInningNumber := strconv.Itoa(playerScore.InningNumber)
		inningData[playerScoreInningNumber] = append(inningData[playerScoreInningNumber], playerDetails)

	}

	var scoreDetails map[string]interface{}
	var emptyDetails map[string]interface{}
	if len(inningData) >= 1 {
		scoreDetails = map[string]interface{}{
			"battingTeam": map[string]interface{}{"id": battingTeam.ID, "public_id": battingTeam.PublicID, "name": battingTeam.Name, "slug": battingTeam.Slug, "shortName": battingTeam.Shortname, "gender": battingTeam.Gender, "national": battingTeam.National, "country": battingTeam.Country, "type": battingTeam.Type},
			"innings":     inningData,
		}
	} else {
		scoreDetails = map[string]interface{}{
			"battingTeam": map[string]interface{}{"id": battingTeam.ID, "public_id": battingTeam.PublicID, "name": battingTeam.Name, "slug": battingTeam.Slug, "shortName": battingTeam.Shortname, "gender": battingTeam.Gender, "national": battingTeam.National, "country": battingTeam.Country, "type": battingTeam.Type},
			"innings":     emptyDetails,
		}
	}

	ctx.JSON(http.StatusAccepted, scoreDetails)
}

type getCricketBowlersRequest struct {
	MatchPublicID string `json:"match_public_id"`
	TeamPublicID  string `json:"team_public_id"`
}

func (s *CricketServer) GetCricketBowlerFunc(ctx *gin.Context) {
	matchPublicIDString := ctx.Query("match_public_id")
	teamPublicIDString := ctx.Query("team_public_id")

	matchPublicID, err := uuid.Parse(matchPublicIDString)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	teamPublicID, err := uuid.Parse(teamPublicIDString)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	gameName := ctx.Param("sport")

	_, err = s.store.GetGamebyName(ctx, gameName)
	if err != nil {
		s.logger.Error("Failed to get the game: ", gin.H{"error": err.Error()})
		return
	}

	playerScore, err := s.store.GetCricketBalls(ctx, matchPublicID, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get cricket bowler data : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	var battingTeamId int64
	var bowlingTeamId int64

	team, err := s.store.GetTeamByPublicID(ctx, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get team by public id: ", err)
		return
	}

	if team.ID == int64(match.HomeTeamID) {
		battingTeamId = int64(match.AwayTeamID)
		bowlingTeamId = team.ID
	} else {
		battingTeamId = int64(match.HomeTeamID)
		bowlingTeamId = team.ID
	}
	fmt.Println("Batting Team ID: ", battingTeamId)

	bowlingTeam, err := s.store.GetTeamByID(ctx, bowlingTeamId)
	if err != nil {
		s.logger.Error("Failed to get players score : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	inningData := make(map[string][]map[string]interface{})
	for _, playerScore := range playerScore {
		playerData, err := s.store.GetPlayerByID(ctx, int64(playerScore.BowlerID))
		if err != nil {
			s.logger.Error("Failed to get players data : ", err)
			ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
		bowlingDetails := map[string]interface{}{
			"player":            map[string]interface{}{"id": playerData.ID, "public_id": playerData.PublicID, "name": playerData.Name, "slug": playerData.Slug, "shortName": playerData.ShortName, "position": playerData.Positions},
			"id":                playerScore.ID,
			"public_id":         playerData.PublicID,
			"match_id":          playerScore.MatchID,
			"team_id":           playerScore.TeamID,
			"bowler_id":         playerScore.BowlerID,
			"ball_number":       playerScore.BallNumber,
			"runs":              playerScore.Runs,
			"wide":              playerScore.Wide,
			"no_ball":           playerScore.NoBall,
			"wickets":           playerScore.Wickets,
			"bowling_status":    playerScore.BowlingStatus,
			"is_current_bowler": playerScore.IsCurrentBowler,
			"inning_number":     playerScore.InningNumber,
		}
		playerScoreInningNumber := strconv.Itoa(playerScore.InningNumber)
		inningData[playerScoreInningNumber] = append(inningData[playerScoreInningNumber], bowlingDetails)
	}

	scoreDetails := map[string]interface{}{
		"bowlingTeam": map[string]interface{}{
			"id":           bowlingTeam.ID,
			"public_id":    bowlingTeam.PublicID,
			"name":         bowlingTeam.Name,
			"slug":         bowlingTeam.Slug,
			"shortName":    bowlingTeam.Shortname,
			"gender":       bowlingTeam.Gender,
			"national":     bowlingTeam.National,
			"country":      bowlingTeam.Country,
			"type":         bowlingTeam.Type,
			"player_count": bowlingTeam.PlayerCount,
		},
		"innings": inningData,
	}

	ctx.JSON(http.StatusAccepted, scoreDetails)
}

func (s *CricketServer) GetCricketWicketsFunc(ctx *gin.Context) {

	matchPublicIDString := ctx.Query("match_public_id")
	teamPublicIDString := ctx.Query("team_public_id")

	matchPublicID, err := uuid.Parse(matchPublicIDString)
	if err != nil {
		s.logger.Error("Failed to parse to int: ", err)
	}

	teamPublicID, err := uuid.Parse(teamPublicIDString)
	if err != nil {
		s.logger.Error("Failed to parse to int: ", err)
	}
	wicketsResponse, err := s.store.GetCricketWickets(ctx, matchPublicID, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get cricket bowler score : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	s.logger.Info("Successfully get the wickets: ", wicketsResponse)

	var wicketsData []map[string]interface{}

	match, err := s.store.GetMatchModelByPublicId(ctx, matchPublicID)
	if err != nil {
		s.logger.Error("Failed to get match : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	team, err := s.store.GetTeamByPublicID(ctx, teamPublicID)
	if err != nil {
		s.logger.Error("Failed to get team : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	_, err = s.store.GetCricketScore(ctx, int32(match.ID), int32(team.ID))
	if err != nil {
		s.logger.Error("Failed to get current score data : ", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	}

	inningData := make(map[string][]map[string]interface{})

	for _, wicket := range wicketsResponse {
		batsmanPlayerData, err := s.store.GetPlayerByID(ctx, int64(wicket.BatsmanID))
		if err != nil {
			s.logger.Error("Failed to get batsman data : ", err)
			ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		}

		bowlerPlayerData, err := s.store.GetPlayerByID(ctx, int64(wicket.BowlerID))
		if err != nil {
			s.logger.Error("Failed to get bowler data : ", err)
			ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		}
		var fielderData *models.Player
		if wicket.FielderID != nil {
			fielderData, err = s.store.GetPlayerByID(ctx, int64(*wicket.FielderID))
			if err != nil {
				s.logger.Error("Failed to get fielder data : ", err)
				ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			}
		}

		wicketData := map[string]interface{}{
			"batsman_player": map[string]interface{}{"id": batsmanPlayerData.ID, "public_id": batsmanPlayerData.PublicID, "name": batsmanPlayerData.Name, "slug": batsmanPlayerData.Slug, "shortName": batsmanPlayerData.ShortName, "position": batsmanPlayerData.Positions},
			"bowler_player":  map[string]interface{}{"id": bowlerPlayerData.ID, "public_id": bowlerPlayerData.PublicID, "name": bowlerPlayerData.Name, "slug": bowlerPlayerData.Slug, "shortName": bowlerPlayerData.ShortName, "position": bowlerPlayerData.Positions},
			"fielder_player": fielderData,
			"id":             wicket.ID,
			"public_id":      wicket.PublicID,
			"match_id":       wicket.MatchID,
			"team_id":        wicket.TeamID,
			"batsman_id":     wicket.BatsmanID,
			"bowler_id":      wicket.BowlerID,
			"inning_number":  wicket.InningNumber,
			"wicket_number":  wicket.WicketsNumber,
			"wicket_type":    wicket.WicketType,
			"ball_number":    wicket.BallNumber,
			"fielder_id":     wicket.FielderID,
			"score":          wicket.Score,
		}

		wicketsData = append(wicketsData, wicketData)
		wicketsInningNumber := strconv.Itoa(wicket.InningNumber)
		inningData[wicketsInningNumber] = append(inningData[wicketsInningNumber], wicketData)
	}

	s.logger.Debug("Successfully update the wickets: ", wicketsData)

	ctx.JSON(http.StatusAccepted, gin.H{
		"inning": inningData,
	})
}

type updateCricketBatsmanScoreRequest struct {
	BatsmanID  int64  `json:"batsman_id"`
	TeamID     int64  `json:"team_id"`
	MatchID    int64  `json:"match_id"`
	Position   string `json:"position"`
	RunsScored int32  `json:"runs_scored"`
	Fours      int32  `json:"fours"`
	Sixes      int32  `json:"sixes"`
}

type updateCricketPlayerStatsRequest struct {
	BatsmanID   int64  `json:"batsman_id"`
	BowlerID    int64  `json:"bowler_id"`
	MatchID     int64  `json:"match_id"`
	Position    string `json:"position"`
	RunsScored  int32  `json:"runs_scored"`
	BowlerBalls int32  `json:"bowler_balls"`
	Fours       int32  `json:"fours"`
	Sixes       int32  `json:"sixes"`
}

// type updateWideRunsRequest struct {
// 	MatchPublicID       string `json:"match_public_id"`
// 	BatsmanPublicID     string `json:"batsman_public_id"`
// 	BowlerPublicID      string `json:"bowler_public_id"`
// 	BattingTeamPublicID string `json:"batting_team_public_id"`
// 	RunsScored          int32  `json:"runs_scored"`
// 	InningNumber        int    `json:"inning_number"`
// }

func (s *CricketServer) UpdateWideBallFunc(ctx *gin.Context) {
	var req struct {
		MatchPublicID       string `json:"match_public_id"`
		BattingTeamPublicID string `json:"batting_team_public_id"`
		BatsmanPublicID     string `json:"batsman_public_id"`
		BowlerPublicID      string `json:"bowler_public_id"`
		RunsScored          int    `json:"runs_scored"`
		InningNumber        int    `json:"inning_number"`
	}

	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid match UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid match UUID format"})
		return
	}

	batsmanTeamPublicID, err := uuid.Parse(req.BattingTeamPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman team UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman team UUID format"})
		return
	}

	batsmanPublicID, err := uuid.Parse(req.BatsmanPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman UUID format"})
		return
	}

	bowlerPublicID, err := uuid.Parse(req.BowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid bowler UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bowler UUID format"})
		return
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	runsScored := req.RunsScored
	inningNumber := req.InningNumber

	batsmanResponse, currentBatsman, bowlerResponse, inningScore, err := s.txStore.UpdateWideRunsTx(ctx, matchPublicID, bowlerPublicID, batsmanTeamPublicID, int32(runsScored), inningNumber)
	if err != nil {
		s.logger.Error("Failed to update wide: ", err)
		return
	}

	var nonStrikerResponse models.BatsmanScore
	verifyBatsman, err := s.store.GetPlayerByPublicID(ctx, batsmanPublicID)
	if err != nil {
		s.logger.Error("Failed to update stricker: ", err)
	}

	for _, curBatsman := range currentBatsman {
		if curBatsman.BatsmanID == int32(verifyBatsman.ID) && curBatsman.IsStriker {
			batsmanResponse.IsStriker = curBatsman.IsStriker
		} else if curBatsman.BatsmanID != int32(verifyBatsman.ID) && curBatsman.IsStriker {
			nonStrikerResponse = curBatsman
		} else if curBatsman.BatsmanID == int32(verifyBatsman.ID) && !curBatsman.IsStriker {
			batsmanResponse.IsStriker = curBatsman.IsStriker
		} else if curBatsman.BatsmanID != int32(verifyBatsman.ID) && !curBatsman.IsStriker {
			nonStrikerResponse = curBatsman
		}
	}

	batsmanPlayerData, err := s.store.GetPlayerByID(ctx, int64(batsmanResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	nonStrikerPlayerData, err := s.store.GetPlayerByID(ctx, int64(nonStrikerResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	bowlerPlayerData, err := s.store.GetPlayerByID(ctx, int64(bowlerResponse.BowlerID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	batsman := map[string]interface{}{
		"player":               map[string]interface{}{"id": batsmanPlayerData.ID, "public_id": batsmanPlayerData.PublicID, "name": batsmanPlayerData.Name, "slug": batsmanPlayerData.Slug, "shortName": batsmanPlayerData.ShortName, "position": batsmanPlayerData.Positions},
		"id":                   batsmanResponse.ID,
		"public_id":            batsmanResponse.PublicID,
		"match_id":             batsmanResponse.MatchID,
		"team_id":              batsmanResponse.TeamID,
		"batsman_id":           batsmanResponse.BatsmanID,
		"runs_scored":          batsmanResponse.RunsScored,
		"balls_faced":          batsmanResponse.BallsFaced,
		"fours":                batsmanResponse.Fours,
		"sixes":                batsmanResponse.Sixes,
		"batting_status":       batsmanResponse.BattingStatus,
		"is_striker":           batsmanResponse.IsStriker,
		"is_currently_batting": batsmanResponse.IsCurrentlyBatting,
	}

	var emptyBatsman models.BatsmanScore
	var nonStriker map[string]interface{}

	if nonStrikerResponse != emptyBatsman {
		nonStriker = map[string]interface{}{
			"player":               map[string]interface{}{"id": nonStrikerPlayerData.ID, "public_id": nonStrikerPlayerData.PublicID, "name": nonStrikerPlayerData.Name, "slug": nonStrikerPlayerData.Slug, "shortName": nonStrikerPlayerData.ShortName, "position": nonStrikerPlayerData.Positions},
			"id":                   nonStrikerResponse.ID,
			"public_id":            nonStrikerPlayerData.PublicID,
			"match_id":             nonStrikerResponse.MatchID,
			"team_id":              nonStrikerResponse.TeamID,
			"batsman_id":           nonStrikerResponse.BatsmanID,
			"runs_scored":          nonStrikerResponse.RunsScored,
			"balls_faced":          nonStrikerResponse.BallsFaced,
			"fours":                nonStrikerResponse.Fours,
			"sixes":                nonStrikerResponse.Sixes,
			"batting_status":       nonStrikerResponse.BattingStatus,
			"is_striker":           nonStrikerResponse.IsStriker,
			"is_currently_batting": nonStrikerResponse.IsCurrentlyBatting,
		}
	}

	bowler := map[string]interface{}{
		"player":            map[string]interface{}{"id": bowlerPlayerData.ID, "public_id": bowlerPlayerData.PublicID, "name": bowlerPlayerData.Name, "slug": bowlerPlayerData.Slug, "shortName": bowlerPlayerData.ShortName, "position": bowlerPlayerData.Positions},
		"id":                bowlerResponse.ID,
		"public_id":         bowlerResponse.PublicID,
		"match_id":          bowlerResponse.MatchID,
		"team_id":           bowlerResponse.TeamID,
		"bowler_id":         bowlerResponse.BowlerID,
		"ball_number":       bowlerResponse.BallNumber,
		"runs":              bowlerResponse.Runs,
		"wide":              bowlerResponse.Wide,
		"no_ball":           bowlerResponse.NoBall,
		"wickets":           bowlerResponse.Wickets,
		"bowling_status":    bowlerResponse.BowlingStatus,
		"is_current_bowler": bowlerResponse.IsCurrentBowler,
	}

	payload := map[string]interface{}{
		"striker_batsman":     batsman,
		"non_striker_batsman": nonStriker,
		"bowler":              bowler,
		"inning_score":        inningScore,
		"event_type":          "wide",
	}

	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "UPDATE_SCORE", payload)
		if err != nil {
			s.logger.Error("Failed to broadcast cricket wide ball: ", err)
			return
		}
	}

	data := map[string]interface{}{
		"type": "UPDATE_SCORE",
		"payload": map[string]interface{}{
			"striker_batsman":     batsman,
			"non_striker_batsman": nonStriker,
			"bowler":              bowler,
			"inning_score":        inningScore,
			"event_type":          "wide",
		},
	}
	ctx.JSON(http.StatusAccepted, data)
}

func (s *CricketServer) UpdateNoBallsRunsFunc(ctx *gin.Context) {
	var req struct {
		MatchPublicID       string `json:"match_public_id"`
		BattingTeamPublicID string `json:"batting_team_public_id"`
		BatsmanPublicID     string `json:"batsman_public_id"`
		BowlerPublicID      string `json:"bowler_public_id"`
		RunsScored          int    `json:"runs_scored"`
		InningNumber        int    `json:"inning_number"`
	}

	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind: ", err)
		return
	}

	fmt.Println("Req No Ball: ", req)
	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid match UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid match UUID format"})
		return
	}

	battingTeamPublicID, err := uuid.Parse(req.BattingTeamPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman team UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman team UUID format"})
		return
	}

	batsmanPublicID, err := uuid.Parse(req.BatsmanPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman UUID format"})
		return
	}

	bowlerPublicID, err := uuid.Parse(req.BowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid bowler UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bowler UUID format"})
		return
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	runsScored := req.RunsScored
	inningNumber := req.InningNumber

	batsmanResponse, currentBatsman, bowlerResponse, inningScore, err := s.txStore.UpdateCricketNoBallTx(ctx, matchPublicID, bowlerPublicID, battingTeamPublicID, batsmanPublicID, int32(runsScored), inningNumber)
	if err != nil {
		s.logger.Error("Failed to update no_ball: ", err)
		return
	}

	var nonStrikerResponse models.BatsmanScore
	verifyBatsman, err := s.store.GetPlayerByPublicID(ctx, batsmanPublicID)
	if err != nil {
		s.logger.Error("Failed to update stricker: ", err)
	}

	for _, curBatsman := range currentBatsman {
		if curBatsman.BatsmanID == int32(verifyBatsman.ID) && curBatsman.IsStriker {
			batsmanResponse.IsStriker = curBatsman.IsStriker
		} else if curBatsman.BatsmanID != int32(verifyBatsman.ID) && curBatsman.IsStriker {
			nonStrikerResponse = curBatsman
		} else if curBatsman.BatsmanID == int32(verifyBatsman.ID) && !curBatsman.IsStriker {
			batsmanResponse.IsStriker = curBatsman.IsStriker
		} else if curBatsman.BatsmanID != int32(verifyBatsman.ID) && !curBatsman.IsStriker {
			nonStrikerResponse = curBatsman
		}
	}

	batsmanPlayerData, err := s.store.GetPlayerByID(ctx, int64(batsmanResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	nonStrikerPlayerData, err := s.store.GetPlayerByID(ctx, int64(nonStrikerResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	bowlerPlayerData, err := s.store.GetPlayerByID(ctx, int64(bowlerResponse.BowlerID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	batsman := map[string]interface{}{
		"player":               map[string]interface{}{"id": batsmanPlayerData.ID, "public_id": batsmanPlayerData.PublicID, "name": batsmanPlayerData.Name, "slug": batsmanPlayerData.Slug, "shortName": batsmanPlayerData.ShortName, "position": batsmanPlayerData.Positions},
		"id":                   batsmanResponse.ID,
		"public_id":            batsmanResponse.PublicID,
		"match_id":             batsmanResponse.MatchID,
		"team_id":              batsmanResponse.TeamID,
		"batsman_id":           batsmanResponse.BatsmanID,
		"runs_scored":          batsmanResponse.RunsScored,
		"balls_faced":          batsmanResponse.BallsFaced,
		"fours":                batsmanResponse.Fours,
		"sixes":                batsmanResponse.Sixes,
		"batting_status":       batsmanResponse.BattingStatus,
		"is_striker":           batsmanResponse.IsStriker,
		"is_currently_batting": batsmanResponse.IsCurrentlyBatting,
		"inning_number":        batsmanResponse.InningNumber,
	}

	var emptyBatsman models.BatsmanScore
	var nonStriker map[string]interface{}

	if nonStrikerResponse != emptyBatsman {
		nonStriker = map[string]interface{}{
			"player":               map[string]interface{}{"id": nonStrikerPlayerData.ID, "public_id": nonStrikerPlayerData.PublicID, "name": nonStrikerPlayerData.Name, "slug": nonStrikerPlayerData.Slug, "shortName": nonStrikerPlayerData.ShortName, "position": nonStrikerPlayerData.Positions},
			"id":                   nonStrikerResponse.ID,
			"public_id":            nonStrikerPlayerData.PublicID,
			"match_id":             nonStrikerResponse.MatchID,
			"team_id":              nonStrikerResponse.TeamID,
			"batsman_id":           nonStrikerResponse.BatsmanID,
			"runs_scored":          nonStrikerResponse.RunsScored,
			"balls_faced":          nonStrikerResponse.BallsFaced,
			"fours":                nonStrikerResponse.Fours,
			"sixes":                nonStrikerResponse.Sixes,
			"batting_status":       nonStrikerResponse.BattingStatus,
			"is_striker":           nonStrikerResponse.IsStriker,
			"is_currently_batting": nonStrikerResponse.IsCurrentlyBatting,
			"inning_number":        nonStrikerResponse.InningNumber,
		}
	}

	bowler := map[string]interface{}{
		"player":            map[string]interface{}{"id": bowlerPlayerData.ID, "public_id": bowlerPlayerData.PublicID, "name": bowlerPlayerData.Name, "slug": bowlerPlayerData.Slug, "shortName": bowlerPlayerData.ShortName, "position": bowlerPlayerData.Positions},
		"id":                bowlerResponse.ID,
		"public_id":         bowlerResponse.PublicID,
		"match_id":          bowlerResponse.MatchID,
		"team_id":           bowlerResponse.TeamID,
		"bowler_id":         bowlerResponse.BowlerID,
		"ball_number":       bowlerResponse.BallNumber,
		"runs":              bowlerResponse.Runs,
		"wide":              bowlerResponse.Wide,
		"no_ball":           bowlerResponse.NoBall,
		"wickets":           bowlerResponse.Wickets,
		"bowling_status":    bowlerResponse.BowlingStatus,
		"is_current_bowler": bowlerResponse.IsCurrentBowler,
		"inning_number":     bowlerResponse.InningNumber,
	}

	payload := map[string]interface{}{
		"striker_batsman":     batsman,
		"non_striker_batsman": nonStriker,
		"bowler":              bowler,
		"inning_score":        inningScore,
		"event_type":          "no_ball",
	}

	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "UPDATE_SCORE", payload)
		if err != nil {
			s.logger.Error("Failed to broadcast noball: ", err)
			return
		}
	}

	data := map[string]interface{}{
		"type": "UPDATE_SCORE",
		"payload": map[string]interface{}{
			"striker_batsman":     batsman,
			"non_striker_batsman": nonStriker,
			"bowler":              bowler,
			"inning_score":        inningScore,
			"event_type":          "no_ball",
		},
	}
	ctx.JSON(http.StatusAccepted, data)
}

func (s *CricketServer) AddCricketWicketsFunc(ctx *gin.Context) {

	var req struct {
		MatchPublicID       string `json:"match_public_id"`
		BattingTeamPublicID string `json:"batting_team_public_id"`
		BatsmanPublicID     string `json:"batsman_public_id"`
		BowlerPublicID      string `json:"bowler_public_id"`
		FielderPublicID     string `json:"fielder_public_id"`
		RunsScored          int    `json:"runs_scored"`
		InningNumber        int    `json:"inning_number"`
		WicketNumber        int    `json:"wicket_number"`
		BallNumber          int    `json:"ball_number"`
		WicketType          string `json:"wicket_type"`
		BowlType            string `json:"bowl_type"`
		ToggleStriker       bool   `json:"toggle_striker"`
	}

	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind: ", err)
		return
	}

	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	battingTeamID, err := uuid.Parse(req.BattingTeamPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	batsmanPublicID, err := uuid.Parse(req.BatsmanPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	bowlerPublicID, err := uuid.Parse(req.BowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	fielderPublicID, err := uuid.Parse(req.FielderPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	runsScored := int(req.RunsScored)
	inningNumber := int(req.InningNumber)
	wicketNumber := int(req.WicketNumber)
	ballNumber := int(req.BallNumber)
	wicketType := req.WicketType
	toggleStriker := req.ToggleStriker

	cricketScore, err := s.store.GetCricketScoreByInning(ctx, matchPublicID, battingTeamID, inningNumber)
	if err != nil {
		s.logger.Error("Failed to get cricket score: ", err)
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	var outBatsmanResponse *models.BatsmanScore
	var notOutBatsmanResponse *models.BatsmanScore
	var bowlerResponse *models.BowlerScore
	var inningScoreResponse *models.CricketScore
	var wicketResponse *models.Wicket

	outBatsmanResponse, notOutBatsmanResponse, bowlerResponse, inningScoreResponse, wicketResponse, err = s.txStore.AddCricketWicketTx(ctx,
		matchPublicID,
		battingTeamID,
		batsmanPublicID,
		bowlerPublicID,
		wicketNumber,
		wicketType,
		ballNumber,
		fielderPublicID,
		cricketScore,
		&req.BowlType,
		int32(runsScored),
		inningNumber,
		toggleStriker,
	)
	if err != nil {
		s.logger.Error("Failed to add the cricket wicket: ", err)
		return
	}

	matchData, err := s.store.GetMatchModelByPublicId(ctx, matchPublicID)
	if err != nil {
		s.logger.Error("failed to get match: ", err)
		return
	}

	outBatsmanPlayerData, err := s.store.GetPlayerByID(ctx, int64(outBatsmanResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
	}

	notOutBatsmanPlayerData, err := s.store.GetPlayerByID(ctx, int64(notOutBatsmanResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
	}

	bowlerPlayerData, err := s.store.GetPlayerByID(ctx, int64(bowlerResponse.BowlerID))
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
	}

	var fielderPlayerData *models.Player

	if wicketResponse.FielderID != nil {
		fielderPlayerData, err = s.store.GetPlayerByID(ctx, int64(*wicketResponse.FielderID))
		if err != nil {
			s.logger.Error("Failed to get Player: ", err)
		}
	}

	err = s.UpdateMatchStatusAndResult(ctx, inningScoreResponse, matchData, matchData.ID)
	if err != nil {
		s.logger.Error("Failed to update match status and result: ", err)
		return
	}

	outBatsmanScore := map[string]interface{}{
		"player":               map[string]interface{}{"id": outBatsmanPlayerData.ID, "public_id": outBatsmanPlayerData.PublicID, "name": outBatsmanPlayerData.Name, "slug": outBatsmanPlayerData.Slug, "shortName": outBatsmanPlayerData.ShortName, "position": outBatsmanPlayerData.Positions},
		"id":                   outBatsmanResponse.ID,
		"public_id":            outBatsmanResponse.PublicID,
		"match_id":             outBatsmanResponse.MatchID,
		"team_id":              outBatsmanResponse.TeamID,
		"batsman_id":           outBatsmanResponse.BatsmanID,
		"runs_scored":          outBatsmanResponse.RunsScored,
		"balls_faced":          outBatsmanResponse.BallsFaced,
		"fours":                outBatsmanResponse.Fours,
		"sixes":                outBatsmanResponse.Sixes,
		"batting_status":       outBatsmanResponse.BattingStatus,
		"is_striker":           outBatsmanResponse.IsStriker,
		"is_currently_batting": outBatsmanResponse.IsCurrentlyBatting,
		"inning_number":        outBatsmanResponse.InningNumber,
	}

	notOutBatsmanScore := map[string]interface{}{
		"player":               map[string]interface{}{"id": notOutBatsmanPlayerData.ID, "public_id": notOutBatsmanPlayerData.PublicID, "name": notOutBatsmanPlayerData.Name, "slug": notOutBatsmanPlayerData.Slug, "shortName": notOutBatsmanPlayerData.ShortName, "position": notOutBatsmanPlayerData.Positions},
		"id":                   notOutBatsmanResponse.ID,
		"public_id":            notOutBatsmanResponse.PublicID,
		"match_id":             notOutBatsmanResponse.MatchID,
		"team_id":              notOutBatsmanResponse.TeamID,
		"batsman_id":           notOutBatsmanResponse.BatsmanID,
		"runs_scored":          notOutBatsmanResponse.RunsScored,
		"balls_faced":          notOutBatsmanResponse.BallsFaced,
		"fours":                notOutBatsmanResponse.Fours,
		"sixes":                notOutBatsmanResponse.Sixes,
		"batting_status":       notOutBatsmanResponse.BattingStatus,
		"is_striker":           notOutBatsmanResponse.IsStriker,
		"is_currently_batting": notOutBatsmanResponse.IsCurrentlyBatting,
		"inning_number":        notOutBatsmanResponse.InningNumber,
	}

	bowler := map[string]interface{}{
		"player":            map[string]interface{}{"id": bowlerPlayerData.ID, "public_id": bowlerPlayerData.PublicID, "name": bowlerPlayerData.Name, "slug": bowlerPlayerData.Slug, "shortName": bowlerPlayerData.ShortName, "position": bowlerPlayerData.Positions},
		"id":                bowlerResponse.ID,
		"public_id":         bowlerResponse.PublicID,
		"match_id":          bowlerResponse.MatchID,
		"team_id":           bowlerResponse.TeamID,
		"bowler_id":         bowlerResponse.BowlerID,
		"ball_number":       bowlerResponse.BallNumber,
		"runs":              bowlerResponse.Runs,
		"wide":              bowlerResponse.Wide,
		"no_ball":           bowlerResponse.NoBall,
		"wickets":           bowlerResponse.Wickets,
		"bowling_status":    bowlerResponse.BowlingStatus,
		"is_current_bowler": bowlerResponse.IsCurrentBowler,
	}

	wickets := map[string]interface{}{
		"batsman_player": map[string]interface{}{"id": outBatsmanPlayerData.ID, "public_id": outBatsmanPlayerData.PublicID, "name": outBatsmanPlayerData.Name, "slug": outBatsmanPlayerData.Slug, "shortName": outBatsmanPlayerData.ShortName, "position": outBatsmanPlayerData.Positions},
		"bowler_player":  map[string]interface{}{"id": bowlerPlayerData.ID, "public_id": bowlerPlayerData.PublicID, "name": bowlerPlayerData.Name, "slug": bowlerPlayerData.Slug, "shortName": bowlerPlayerData.ShortName, "position": bowlerPlayerData.Positions},
		"fielder_player": fielderPlayerData,
		"id":             wicketResponse.ID,
		"public_id":      wicketResponse.PublicID,
		"match_id":       wicketResponse.MatchID,
		"team_id":        wicketResponse.TeamID,
		"batsman_id":     wicketResponse.BatsmanID,
		"bowler_id":      wicketResponse.BowlerID,
		"wicket_number":  wicketResponse.WicketsNumber,
		"wicket_type":    wicketResponse.WicketType,
		"ball_number":    wicketResponse.BallNumber,
		"fielder_id":     wicketResponse.FielderID,
		"score":          wicketResponse.Score,
		"inning_number":  wicketResponse.InningNumber,
	}

	payload := map[string]interface{}{
		"out_batsman":     outBatsmanScore,
		"not_out_batsman": notOutBatsmanScore,
		"bowler":          bowler,
		"inning_score":    inningScoreResponse,
		"wickets":         wickets,
		"match":           matchData,
		"event_type":      "wicket",
	}

	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "UPDATE_SCORE", payload)
		if err != nil {
			s.logger.Error("Failed to broadcast cricket add wicket: ", err)
			return
		}
	}

	data := map[string]interface{}{
		"type": "UPDATE_SCORE",
		"payload": map[string]interface{}{
			"out_batsman":     outBatsmanScore,
			"not_out_batsman": notOutBatsmanScore,
			"bowler":          bowler,
			"inning_score":    inningScoreResponse,
			"wickets":         wickets,
			"match":           matchData,
			"event_type":      "wicket",
		},
	}
	ctx.JSON(http.StatusAccepted, data)
}

func (s *CricketServer) UpdateInningScoreFunc(ctx *gin.Context) {

	var req struct {
		MatchPublicID       string `json:"match_public_id"`
		BatsmanTeamPublicID string `json:"batsman_team_public_id"`
		BatsmanPublicID     string `json:"batsman_public_id"`
		BowlerPublicID      string `json:"bowler_public_id"`
		RunsScored          int    `json:"runs_scored"`
		InningNumber        int    `json:"inning_number"`
	}

	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind: ", err)
		return
	}

	// Parse UUIDs
	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid match UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid match UUID format"})
		return
	}

	batsmanTeamPublicID, err := uuid.Parse(req.BatsmanTeamPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman team UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman team UUID format"})
		return
	}

	batsmanPublicID, err := uuid.Parse(req.BatsmanPublicID)
	if err != nil {
		s.logger.Error("Invalid batsman UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman UUID format"})
		return
	}

	bowlerPublicID, err := uuid.Parse(req.BowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid bowler UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bowler UUID format"})
		return
	}

	runsScored := req.RunsScored
	inningNumber := req.InningNumber

	// Check if inning is already completed to prevent repeated updates
	cricketScore, err := s.store.GetCricketScoreByInning(ctx, matchPublicID, batsmanTeamPublicID, req.InningNumber)
	if err != nil {
		s.logger.Error("Failed to get cricket score: ", err)
		return
	}
	if cricketScore.IsInningCompleted {
		s.logger.Info("Inning already completed, skipping update")
		return
	}

	fmt.Println("Batsman: ", batsmanPublicID)
	fmt.Println("Bowler: ", bowlerPublicID)

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	// Update inning score
	batsmanResponse, bowlerResponse, inningScore, err := s.store.UpdateInningScore(
		ctx,
		matchPublicID,
		batsmanTeamPublicID,
		batsmanPublicID,
		bowlerPublicID,
		int32(runsScored),
		inningNumber,
	)
	if err != nil {
		s.logger.Error("Failed to update innings: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	fmt.Println("Batsman Score: ", batsmanResponse)

	// Get match data
	matchData, err := s.store.GetMatchModelByPublicId(ctx, matchPublicID)
	if err != nil {
		s.logger.Error("failed to get match by match id: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get match data"})
		return
	}

	// Check if innings should end
	inningsCompleted := false
	totalBalls := inningScore.Overs // Assuming this stores total balls

	if inningScore.Wickets >= 10 {
		fmt.Println("Innings ending: 10 wickets fallen")
		inningsCompleted = true
	} else if *matchData.MatchFormat == "T20" && totalBalls >= 120 {
		fmt.Println("Innings ending: T20 overs completed (120 balls)")
		inningsCompleted = true
	} else if *matchData.MatchFormat == "ODI" && totalBalls >= 300 {
		fmt.Println("Innings ending: ODI overs completed (300 balls)")
		inningsCompleted = true
	}

	// Handle striker rotation BEFORE innings completion
	var currentBatsman []models.BatsmanScore
	var strikerResponse models.BatsmanScore
	var nonStrikerResponse models.BatsmanScore
	var striker interface{}
	var nonStriker interface{}
	var bowler interface{}

	// if !inningsCompleted {
	// Determine if striker should rotate
	shouldRotateStriker := false

	if bowlerResponse.BallNumber%6 == 0 && runsScored%2 == 0 {
		// Last ball of over, even runs -> rotate
		shouldRotateStriker = true
		fmt.Println("Rotating: Last ball of over with even runs")
	} else if bowlerResponse.BallNumber%6 != 0 && runsScored%2 != 0 {
		// Not last ball, odd runs -> rotate
		shouldRotateStriker = true
		fmt.Println("Rotating: Odd runs scored")
	}

	if shouldRotateStriker {
		currentBatsman, err = s.store.ToggleCricketStricker(ctx, matchPublicID, inningNumber)
		if err != nil {
			s.logger.Error("Failed to toggle striker: ", err)
		}
	} else {
		currentBatsman, err = s.store.GetCurrentBattingBatsman(ctx, matchPublicID, batsmanTeamPublicID, inningNumber)
		if err != nil {
			s.logger.Error("Failed to get current batsmen: ", err)
		}

	}

	fmt.Println("Current batsmen after rotation: ", currentBatsman)

	// Assign striker and non-striker
	fmt.Println("Current Batsman: ", currentBatsman)
	for _, curBatsman := range currentBatsman {
		if curBatsman.IsStriker {
			strikerResponse = curBatsman
		} else {
			nonStrikerResponse = curBatsman
		}
	}

	// Determine event type
	inningStatus := "in_progress"
	if inningsCompleted {
		inningStatus = "completed"
	}

	// Fetch player details
	fmt.Println("Striker Response: ", strikerResponse)
	strikerPlayerData, err := s.store.GetPlayerByID(ctx, int64(strikerResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get striker player: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get striker data"})
		return
	}

	fmt.Println("Non Striker Response: ", nonStrikerResponse)

	nonStrikerPlayerData, err := s.store.GetPlayerByID(ctx, int64(nonStrikerResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get non-striker player: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get non-striker data"})
		return
	}

	bowlerPlayerData, err := s.store.GetPlayerByPublicID(ctx, bowlerPublicID)
	if err != nil {
		s.logger.Error("Failed to get bowler player: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get bowler data"})
		return
	}

	// Build response objects
	striker = map[string]interface{}{
		"player": map[string]interface{}{
			"id":        strikerPlayerData.ID,
			"public_id": strikerPlayerData.PublicID,
			"name":      strikerPlayerData.Name,
			"slug":      strikerPlayerData.Slug,
			"shortName": strikerPlayerData.ShortName,
			"position":  strikerPlayerData.Positions,
		},
		"id":                   strikerResponse.ID,
		"public_id":            strikerResponse.PublicID,
		"match_id":             strikerResponse.MatchID,
		"team_id":              strikerResponse.TeamID,
		"batsman_id":           strikerResponse.BatsmanID,
		"runs_scored":          strikerResponse.RunsScored,
		"balls_faced":          strikerResponse.BallsFaced,
		"fours":                strikerResponse.Fours,
		"sixes":                strikerResponse.Sixes,
		"batting_status":       strikerResponse.BattingStatus,
		"is_striker":           strikerResponse.IsStriker,
		"is_currently_batting": strikerResponse.IsCurrentlyBatting,
		"inning_number":        strikerResponse.InningNumber,
	}

	nonStriker = map[string]interface{}{
		"player": map[string]interface{}{
			"id":        nonStrikerPlayerData.ID,
			"public_id": nonStrikerPlayerData.PublicID,
			"name":      nonStrikerPlayerData.Name,
			"slug":      nonStrikerPlayerData.Slug,
			"shortName": nonStrikerPlayerData.ShortName,
			"position":  nonStrikerPlayerData.Positions,
		},
		"id":                   nonStrikerResponse.ID,
		"public_id":            nonStrikerResponse.PublicID,
		"match_id":             nonStrikerResponse.MatchID,
		"team_id":              nonStrikerResponse.TeamID,
		"batsman_id":           nonStrikerResponse.BatsmanID,
		"runs_scored":          nonStrikerResponse.RunsScored,
		"balls_faced":          nonStrikerResponse.BallsFaced,
		"fours":                nonStrikerResponse.Fours,
		"sixes":                nonStrikerResponse.Sixes,
		"batting_status":       nonStrikerResponse.BattingStatus,
		"is_striker":           nonStrikerResponse.IsStriker,
		"is_currently_batting": nonStrikerResponse.IsCurrentlyBatting,
		"inning_number":        nonStrikerResponse.InningNumber,
	}

	fmt.Println("Striker: ", striker)
	fmt.Println("Non Striker: ", nonStriker)

	bowler = map[string]interface{}{
		"player": map[string]interface{}{
			"id":        bowlerPlayerData.ID,
			"public_id": bowlerPlayerData.PublicID,
			"name":      bowlerPlayerData.Name,
			"slug":      bowlerPlayerData.Slug,
			"shortName": bowlerPlayerData.ShortName,
			"position":  bowlerPlayerData.Positions,
		},
		"id":                bowlerResponse.ID,
		"public_id":         bowlerResponse.PublicID,
		"match_id":          bowlerResponse.MatchID,
		"team_id":           bowlerResponse.TeamID,
		"bowler_id":         bowlerResponse.BowlerID,
		"ball_number":       bowlerResponse.BallNumber,
		"runs":              bowlerResponse.Runs,
		"wide":              bowlerResponse.Wide,
		"no_ball":           bowlerResponse.NoBall,
		"wickets":           bowlerResponse.Wickets,
		"bowling_status":    bowlerResponse.BowlingStatus,
		"is_current_bowler": bowlerResponse.IsCurrentBowler,
		"inning_number":     bowlerResponse.InningNumber,
	}
	inningPayload := map[string]interface{}{
		"id":                  inningScore.ID,
		"public_id":           inningScore.PublicID,
		"match_id":            inningScore.MatchID,
		"team_id":             inningScore.TeamID,
		"inning_number":       inningScore.InningNumber,
		"score":               inningScore.Score,
		"wickets":             inningScore.Wickets,
		"overs":               inningScore.Overs,
		"run_rate":            inningScore.RunRate,
		"target_run_rate":     inningScore.TargetRunRate,
		"follow_on":           inningScore.FollowOn,
		"is_inning_completed": inningScore.IsInningCompleted,
		"declared":            inningScore.Declared,
		"inning_status":       inningScore.InningStatus,
	}

	inningData := map[string]interface{}{
		"striker_batsman":     striker,
		"non_striker_batsman": nonStriker,
		"bowler":              bowler,
		"inning_score":        inningPayload,
		"event_type":          "normal",
	}

	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "UPDATE_SCORE", inningData)
		if err != nil {
			s.logger.Error("Failed to broadcast update score: ", err)
			return
		}
	}

	data := map[string]interface{}{
		"type": "UPDATE_SCORE",
		"payload": map[string]interface{}{
			"striker_batsman":     striker,
			"non_striker_batsman": nonStriker,
			"bowler":              bowler,
			"inning_score":        inningPayload,
			"event_type":          "normal",
		},
	}

	ctx.JSON(http.StatusAccepted, data)

	if inningStatus == "Completed" {
		s.UpdateCricketInningStatusWS(ctx, matchPublicID, batsmanTeamPublicID, batsmanPublicID, bowlerPublicID, inningNumber)
	}

	// fmt.Println("Response data: ", data)
	// return data, inningStatus
}

func (s *CricketServer) UpdateCricketInningStatusWS(ctx *gin.Context, matchPublicID, batsmanTeamPublicID, batsmanPublicID, bowlerPublicID uuid.UUID, inningNumber int) {

	// content := message
	// matchPublicID, err := uuid.Parse(content["match_public_id"].(string))
	// if err != nil {
	// 	s.logger.Error("Invalid match UUID format", err)
	// 	ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid match UUID format"})
	// 	return
	// }

	// batsmanTeamPublicID, err := uuid.Parse(content["batsman_team_public_id"].(string))
	// if err != nil {
	// 	s.logger.Error("Invalid batsman team UUID format", err)
	// 	ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid batsman team UUID format"})
	// 	return
	// }

	// fmt.Println("Message Data: ", content["bowler_public_id"].(string))
	// bowlerPublicID, err := uuid.Parse(content["bowler_public_id"].(string))
	// if err != nil {
	// 	s.logger.Error("Invalid bowler UUID format", err)
	// 	ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid bowler UUID format"})
	// 	return
	// }
	// inningNumber := int(content["inning_number"].(float64))

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	currBatsman, err := s.store.GetCurrentBattingBatsman(ctx, matchPublicID, batsmanTeamPublicID, inningNumber)
	if err != nil {
		s.logger.Error("Faield to end the inning ", err)
		return
	}

	var strikerResponse models.BatsmanScore
	var nonStrikerResponse models.BatsmanScore

	for _, curr := range currBatsman {
		if curr.IsStriker {
			strikerResponse = curr
		} else {
			nonStrikerResponse = curr
		}
	}
	fmt.Println("Lien no 309")

	inningScore, _, bowlerResponse, err := s.store.UpdateInningEndStatusByPublicID(ctx, matchPublicID, batsmanTeamPublicID, inningNumber)
	if err != nil {
		s.logger.Error("Faield to end the inning ")
	}
	fmt.Println("INNING SCORE: ", inningScore)
	fmt.Println("BowlerResoponse; ", bowlerResponse)

	strikerPlayerData, err := s.store.GetPlayerByID(ctx, int64(strikerResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get striker player: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get striker data"})
	}

	nonStrikerPlayerData, err := s.store.GetPlayerByID(ctx, int64(nonStrikerResponse.BatsmanID))
	if err != nil {
		s.logger.Error("Failed to get non-striker player: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get non-striker data"})

	}

	bowlerPlayerData, err := s.store.GetPlayerByPublicID(ctx, bowlerPublicID)
	if err != nil {
		s.logger.Error("Failed to get bowler player: ", err)
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get bowler data"})
	}

	// Build response objects
	striker := map[string]interface{}{
		"player": map[string]interface{}{
			"id":        strikerPlayerData.ID,
			"public_id": strikerPlayerData.PublicID,
			"name":      strikerPlayerData.Name,
			"slug":      strikerPlayerData.Slug,
			"shortName": strikerPlayerData.ShortName,
			"position":  strikerPlayerData.Positions,
		},
		"id":                   strikerResponse.ID,
		"public_id":            strikerResponse.PublicID,
		"match_id":             strikerResponse.MatchID,
		"team_id":              strikerResponse.TeamID,
		"batsman_id":           strikerResponse.BatsmanID,
		"runs_scored":          strikerResponse.RunsScored,
		"balls_faced":          strikerResponse.BallsFaced,
		"fours":                strikerResponse.Fours,
		"sixes":                strikerResponse.Sixes,
		"batting_status":       strikerResponse.BattingStatus,
		"is_striker":           strikerResponse.IsStriker,
		"is_currently_batting": strikerResponse.IsCurrentlyBatting,
		"inning_number":        strikerResponse.InningNumber,
	}

	nonStriker := map[string]interface{}{
		"player": map[string]interface{}{
			"id":        nonStrikerPlayerData.ID,
			"public_id": nonStrikerPlayerData.PublicID,
			"name":      nonStrikerPlayerData.Name,
			"slug":      nonStrikerPlayerData.Slug,
			"shortName": nonStrikerPlayerData.ShortName,
			"position":  nonStrikerPlayerData.Positions,
		},
		"id":                   nonStrikerResponse.ID,
		"public_id":            nonStrikerResponse.PublicID,
		"match_id":             nonStrikerResponse.MatchID,
		"team_id":              nonStrikerResponse.TeamID,
		"batsman_id":           nonStrikerResponse.BatsmanID,
		"runs_scored":          nonStrikerResponse.RunsScored,
		"balls_faced":          nonStrikerResponse.BallsFaced,
		"fours":                nonStrikerResponse.Fours,
		"sixes":                nonStrikerResponse.Sixes,
		"batting_status":       nonStrikerResponse.BattingStatus,
		"is_striker":           nonStrikerResponse.IsStriker,
		"is_currently_batting": nonStrikerResponse.IsCurrentlyBatting,
		"inning_number":        nonStrikerResponse.InningNumber,
	}

	bowler := map[string]interface{}{
		"player": map[string]interface{}{
			"id":        bowlerPlayerData.ID,
			"public_id": bowlerPlayerData.PublicID,
			"name":      bowlerPlayerData.Name,
			"slug":      bowlerPlayerData.Slug,
			"shortName": bowlerPlayerData.ShortName,
			"position":  bowlerPlayerData.Positions,
		},
		"id":                bowlerResponse.ID,
		"public_id":         bowlerResponse.PublicID,
		"match_id":          bowlerResponse.MatchID,
		"team_id":           bowlerResponse.TeamID,
		"bowler_id":         bowlerResponse.BowlerID,
		"ball_number":       bowlerResponse.BallNumber,
		"runs":              bowlerResponse.Runs,
		"wide":              bowlerResponse.Wide,
		"no_ball":           bowlerResponse.NoBall,
		"wickets":           bowlerResponse.Wickets,
		"bowling_status":    bowlerResponse.BowlingStatus,
		"is_current_bowler": bowlerResponse.IsCurrentBowler,
		"inning_number":     bowlerResponse.InningNumber,
	}
	inningPayload := map[string]interface{}{
		"id":                  inningScore.ID,
		"public_id":           inningScore.PublicID,
		"match_id":            inningScore.MatchID,
		"team_id":             inningScore.TeamID,
		"inning_number":       inningScore.InningNumber,
		"score":               inningScore.Score,
		"wickets":             inningScore.Wickets,
		"overs":               inningScore.Overs,
		"run_rate":            inningScore.RunRate,
		"target_run_rate":     inningScore.TargetRunRate,
		"follow_on":           inningScore.FollowOn,
		"is_inning_completed": inningScore.IsInningCompleted,
		"declared":            inningScore.Declared,
		"inning_status":       inningScore.InningStatus,
	}

	payload := map[string]interface{}{
		"striker":       striker,
		"non_striker":   nonStriker,
		"bowler":        bowler,
		"inning_score":  inningPayload,
		"inning_status": "completed",
		"event_type":    "normal",
	}

	data := map[string]interface{}{
		"type": "INNING_STATUS",
		"payload": map[string]interface{}{
			"striker":       striker,
			"non_striker":   nonStriker,
			"bowler":        bowler,
			"inning_score":  inningPayload,
			"inning_status": "completed",
			"event_type":    "normal",
		},
	}

	if s.scoreBroadcaster != nil {
		err := s.scoreBroadcaster.BroadcastCricketEvent(ctx, "INNING_STATUS", payload)
		if err != nil {
			s.logger.Error("Failed to broadcast update score: ", err)
			return
		}
	}
	ctx.JSON(http.StatusAccepted, data)
}

func (s *CricketServer) UpdateBowlingBowlerFunc(ctx *gin.Context) {
	var req struct {
		MatchPublicID         string `json:"match_public_id"`
		TeamPublicID          string `json:"team_public_id"`
		CurrentBowlerPublicID string `json:"current_bowler_public_id"`
		NextBowlerPublicID    string `json:"next_bowler_public_id"`
		InningNumber          int    `json:"inning_number"`
	}

	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		s.logger.Error("Failed to bind: ", err)
		return
	}

	matchPublicID, err := uuid.Parse(req.MatchPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	teamPublicID, err := uuid.Parse(req.TeamPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	currentBowlerPublicID, err := uuid.Parse(req.CurrentBowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	nextBowlerPublicID, err := uuid.Parse(req.NextBowlerPublicID)
	if err != nil {
		s.logger.Error("Invalid UUID format", err)
		ctx.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"code": "VALIDATION_ERROR",
			"message": "Invalid UUID format",
		})
		return
	}

	authPayload := ctx.MustGet(pkg.AuthorizationPayloadKey).(*token.Payload)

	match, err := s.store.GetTournamentMatchByMatchID(ctx, matchPublicID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Tournamet not found"})
		return
	}

	isExists, err := s.store.GetTournamentUserRole(ctx, int32(match.TournamentID), authPayload.UserID)
	if err != nil {
		ctx.JSON(404, gin.H{"error": "Check  failed"})
		return
	}
	if !isExists {
		ctx.JSON(403, gin.H{"error": "You do not own this match"})
		return
	}

	currentBowlerResponse, nextBowlerResponse, err := s.txStore.UpdateBowlingBowlerStatusTx(ctx, matchPublicID, teamPublicID, currentBowlerPublicID, nextBowlerPublicID, req.InningNumber)
	if err != nil {
		s.logger.Error("Failed to update current bowler status: ", err)
		return
	}

	nextPlayerData, err := s.store.GetPlayerByPublicID(ctx, nextBowlerResponse.PublicID)
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	currentPlayerData, err := s.store.GetPlayerByPublicID(ctx, currentBowlerResponse.PublicID)
	if err != nil {
		s.logger.Error("Failed to get Player: ", err)
		return
	}

	nextBowler := map[string]interface{}{
		"player":            map[string]interface{}{"id": nextPlayerData.ID, "public_id": nextPlayerData.PublicID, "name": nextPlayerData.Name, "slug": nextPlayerData.Slug, "shortName": nextPlayerData.ShortName, "position": nextPlayerData.Positions},
		"id":                nextBowlerResponse.ID,
		"public_id":         nextBowlerResponse.PublicID,
		"match_id":          nextBowlerResponse.MatchID,
		"team_id":           nextBowlerResponse.TeamID,
		"bowler_id":         nextBowlerResponse.BowlerID,
		"ball_number":       nextBowlerResponse.BallNumber,
		"runs":              nextBowlerResponse.Runs,
		"wide":              nextBowlerResponse.Wide,
		"no_ball":           nextBowlerResponse.NoBall,
		"wickets":           nextBowlerResponse.Wickets,
		"bowling_status":    nextBowlerResponse.BowlingStatus,
		"is_current_bowler": nextBowlerResponse.IsCurrentBowler,
		"inning_number":     nextBowlerResponse.InningNumber,
	}

	currentBowler := map[string]interface{}{
		"player":            map[string]interface{}{"id": currentPlayerData.ID, "public_id": currentPlayerData.PublicID, "name": currentPlayerData.Name, "slug": currentPlayerData.Slug, "shortName": currentPlayerData.ShortName, "position": currentPlayerData.Positions},
		"id":                currentBowlerResponse.ID,
		"public_id":         currentBowlerResponse.PublicID,
		"match_id":          currentBowlerResponse.MatchID,
		"team_id":           currentBowlerResponse.TeamID,
		"bowler_id":         currentBowlerResponse.BowlerID,
		"ball_number":       currentBowlerResponse.BallNumber,
		"runs":              currentBowlerResponse.Runs,
		"wide":              currentBowlerResponse.Wide,
		"no_ball":           currentBowlerResponse.NoBall,
		"wickets":           currentBowlerResponse.Wickets,
		"bowling_status":    currentBowlerResponse.BowlingStatus,
		"is_current_bowler": currentBowlerResponse.IsCurrentBowler,
		"inning_number":     currentBowlerResponse.InningNumber,
	}

	ctx.JSON(http.StatusOK, gin.H{
		"next_bowler":    nextBowler,
		"current_bowler": currentBowler,
	})

}
