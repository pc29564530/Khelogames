// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: tournament_standing.sql

package db

import (
	"context"
)

const createTournamentStanding = `-- name: CreateTournamentStanding :one
INSERT INTO tournament_standing (
    tournament_id,
    group_id,
    team_id,
    wins,
    loss,
    draw,
    goal_for,
    goal_against,
    goal_difference,
    points
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10 ) RETURNING standing_id, tournament_id, group_id, team_id, wins, loss, draw, goal_for, goal_against, goal_difference, points
`

type CreateTournamentStandingParams struct {
	TournamentID   int64 `json:"tournament_id"`
	GroupID        int64 `json:"group_id"`
	TeamID         int64 `json:"team_id"`
	Wins           int64 `json:"wins"`
	Loss           int64 `json:"loss"`
	Draw           int64 `json:"draw"`
	GoalFor        int64 `json:"goal_for"`
	GoalAgainst    int64 `json:"goal_against"`
	GoalDifference int64 `json:"goal_difference"`
	Points         int64 `json:"points"`
}

func (q *Queries) CreateTournamentStanding(ctx context.Context, arg CreateTournamentStandingParams) (TournamentStanding, error) {
	row := q.db.QueryRowContext(ctx, createTournamentStanding,
		arg.TournamentID,
		arg.GroupID,
		arg.TeamID,
		arg.Wins,
		arg.Loss,
		arg.Draw,
		arg.GoalFor,
		arg.GoalAgainst,
		arg.GoalDifference,
		arg.Points,
	)
	var i TournamentStanding
	err := row.Scan(
		&i.StandingID,
		&i.TournamentID,
		&i.GroupID,
		&i.TeamID,
		&i.Wins,
		&i.Loss,
		&i.Draw,
		&i.GoalFor,
		&i.GoalAgainst,
		&i.GoalDifference,
		&i.Points,
	)
	return i, err
}

const getTournamentStanding = `-- name: GetTournamentStanding :many
SELECT 
    ts.standing_id, ts.tournament_id, ts.group_id, ts.team_id,
    ts.wins, ts.loss, ts.draw, ts.goal_for, ts.goal_against, ts.goal_difference, ts.points,
    t.tournament_name, t.sports,
    c.name
FROM 
    tournament_standing ts
JOIN 
    group_league tg ON ts.group_id = tg.group_id
JOIN 
    tournaments t ON ts.tournament_id = t.id
JOIN 
    teams c ON ts.team_id = c.id
WHERE 
    ts.tournament_id = $1
    AND tg.group_id = $2
    AND t.sports = $3
`

type GetTournamentStandingParams struct {
	TournamentID int64  `json:"tournament_id"`
	GroupID      int64  `json:"group_id"`
	Sports       string `json:"sports"`
}

type GetTournamentStandingRow struct {
	StandingID     int64  `json:"standing_id"`
	TournamentID   int64  `json:"tournament_id"`
	GroupID        int64  `json:"group_id"`
	TeamID         int64  `json:"team_id"`
	Wins           int64  `json:"wins"`
	Loss           int64  `json:"loss"`
	Draw           int64  `json:"draw"`
	GoalFor        int64  `json:"goal_for"`
	GoalAgainst    int64  `json:"goal_against"`
	GoalDifference int64  `json:"goal_difference"`
	Points         int64  `json:"points"`
	TournamentName string `json:"tournament_name"`
	Sports         string `json:"sports"`
	Name           string `json:"name"`
}

func (q *Queries) GetTournamentStanding(ctx context.Context, arg GetTournamentStandingParams) ([]GetTournamentStandingRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentStanding, arg.TournamentID, arg.GroupID, arg.Sports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentStandingRow
	for rows.Next() {
		var i GetTournamentStandingRow
		if err := rows.Scan(
			&i.StandingID,
			&i.TournamentID,
			&i.GroupID,
			&i.TeamID,
			&i.Wins,
			&i.Loss,
			&i.Draw,
			&i.GoalFor,
			&i.GoalAgainst,
			&i.GoalDifference,
			&i.Points,
			&i.TournamentName,
			&i.Sports,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTournamentStanding = `-- name: UpdateTournamentStanding :one
UPDATE tournament_standing AS ts
SET 
    goal_for = COALESCE((
        SELECT SUM(CASE WHEN fs.goal_for IS NOT NULL THEN fs.goal_for ELSE 0 END)
        FROM football_matches_score AS fs
        WHERE fs.team_id = ts.team_id
    ), 0),
    goal_against = COALESCE((
        SELECT SUM(CASE WHEN fs.goal_against IS NOT NULL THEN fs.goal_against ELSE 0 END)
        FROM football_matches_score AS fs
        WHERE fs.team_id = ts.team_id
    ), 0),
    goal_difference = COALESCE((
        SELECT SUM(CASE WHEN fs.goal_for IS NOT NULL THEN fs.goal_for ELSE 0 END) -
               SUM(CASE WHEN fs.goal_against IS NOT NULL THEN fs.goal_against ELSE 0 END)
        FROM football_matches_score AS fs
        WHERE fs.team_id = ts.team_id
    ), 0),
    wins = COALESCE((
        SELECT COUNT(*)
        FROM football_matches_score AS fs
        WHERE fs.team_id = ts.team_id AND fs.goal_for > fs.goal_against
    ), 0),
    loss = COALESCE((
        SELECT COUNT(*)
        FROM football_matches_score AS fs
        WHERE fs.team_id = ts.team_id AND fs.goal_for < fs.goal_against
    ), 0),
    draw = COALESCE((
        SELECT COUNT(*)
        FROM football_matches_score AS fs
        WHERE fs.team_id = ts.team_id AND fs.goal_for = fs.goal_against
    ), 0),
    points = ((wins*3)+draw)
WHERE ts.tournament_id = $1 AND ts.team_id=$2
RETURNING standing_id, tournament_id, group_id, team_id, wins, loss, draw, goal_for, goal_against, goal_difference, points
`

type UpdateTournamentStandingParams struct {
	TournamentID int64 `json:"tournament_id"`
	TeamID       int64 `json:"team_id"`
}

func (q *Queries) UpdateTournamentStanding(ctx context.Context, arg UpdateTournamentStandingParams) (TournamentStanding, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentStanding, arg.TournamentID, arg.TeamID)
	var i TournamentStanding
	err := row.Scan(
		&i.StandingID,
		&i.TournamentID,
		&i.GroupID,
		&i.TeamID,
		&i.Wins,
		&i.Loss,
		&i.Draw,
		&i.GoalFor,
		&i.GoalAgainst,
		&i.GoalDifference,
		&i.Points,
	)
	return i, err
}
