// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: tournament_match.sql

package db

import (
	"context"
)

const getMatch = `-- name: GetMatch :one
SELECT id, tournament_id, away_team_id, home_team_id, start_timestamp, end_timestamp, type, status_code FROM matches
WHERE id=$1 AND tournament_id=$2
`

type GetMatchParams struct {
	ID           int64 `json:"id"`
	TournamentID int64 `json:"tournament_id"`
}

func (q *Queries) GetMatch(ctx context.Context, arg GetMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatch, arg.ID, arg.TournamentID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.AwayTeamID,
		&i.HomeTeamID,
		&i.StartTimestamp,
		&i.EndTimestamp,
		&i.Type,
		&i.StatusCode,
	)
	return i, err
}

const getMatches = `-- name: GetMatches :many
SELECT id, tournament_id, away_team_id, home_team_id, start_timestamp, end_timestamp, type, status_code FROM matches
WHERE tournament_id=$1
ORDER BY id DESC
`

func (q *Queries) GetMatches(ctx context.Context, tournamentID int64) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, getMatches, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.AwayTeamID,
			&i.HomeTeamID,
			&i.StartTimestamp,
			&i.EndTimestamp,
			&i.Type,
			&i.StatusCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesByTournamentID = `-- name: GetMatchesByTournamentID :many
SELECT id, tournament_id, away_team_id, home_team_id, start_timestamp, end_timestamp, type, status_code FROM matches
WHERE tournament_id=$1
ORDER BY id ASC
`

func (q *Queries) GetMatchesByTournamentID(ctx context.Context, tournamentID int64) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, getMatchesByTournamentID, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.AwayTeamID,
			&i.HomeTeamID,
			&i.StartTimestamp,
			&i.EndTimestamp,
			&i.Type,
			&i.StatusCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newMatch = `-- name: NewMatch :one
INSERT INTO matches (
    tournament_id,
    away_team_id,
    home_team_id,
    start_timestamp,
    end_timestamp,
    type,
    status_code
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, tournament_id, away_team_id, home_team_id, start_timestamp, end_timestamp, type, status_code
`

type NewMatchParams struct {
	TournamentID   int64  `json:"tournament_id"`
	AwayTeamID     int64  `json:"away_team_id"`
	HomeTeamID     int64  `json:"home_team_id"`
	StartTimestamp int64  `json:"start_timestamp"`
	EndTimestamp   int64  `json:"end_timestamp"`
	Type           string `json:"type"`
	StatusCode     string `json:"status_code"`
}

func (q *Queries) NewMatch(ctx context.Context, arg NewMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, newMatch,
		arg.TournamentID,
		arg.AwayTeamID,
		arg.HomeTeamID,
		arg.StartTimestamp,
		arg.EndTimestamp,
		arg.Type,
		arg.StatusCode,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.AwayTeamID,
		&i.HomeTeamID,
		&i.StartTimestamp,
		&i.EndTimestamp,
		&i.Type,
		&i.StatusCode,
	)
	return i, err
}

const updateMatchSchedule = `-- name: UpdateMatchSchedule :one
UPDATE matches
SET start_timestamp=$1
WHERE id=$2
RETURNING id, tournament_id, away_team_id, home_team_id, start_timestamp, end_timestamp, type, status_code
`

type UpdateMatchScheduleParams struct {
	StartTimestamp int64 `json:"start_timestamp"`
	ID             int64 `json:"id"`
}

func (q *Queries) UpdateMatchSchedule(ctx context.Context, arg UpdateMatchScheduleParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, updateMatchSchedule, arg.StartTimestamp, arg.ID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.AwayTeamID,
		&i.HomeTeamID,
		&i.StartTimestamp,
		&i.EndTimestamp,
		&i.Type,
		&i.StatusCode,
	)
	return i, err
}
