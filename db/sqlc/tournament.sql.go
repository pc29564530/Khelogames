// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: tournament.sql

package db

import (
	"context"
	"encoding/json"
)

const getTournament = `-- name: GetTournament :one
SELECT id, tournament_name, slug, sports, country, level, start_timestamp, status_code FROM tournaments
WHERE id=$1
`

func (q *Queries) GetTournament(ctx context.Context, id int64) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, getTournament, id)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.TournamentName,
		&i.Slug,
		&i.Sports,
		&i.Country,
		&i.Level,
		&i.StartTimestamp,
		&i.StatusCode,
	)
	return i, err
}

const getTournaments = `-- name: GetTournaments :many
SELECT id, tournament_name, slug, sports, country, level, start_timestamp, status_code FROM tournaments
`

func (q *Queries) GetTournaments(ctx context.Context) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, getTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tournament
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.TournamentName,
			&i.Slug,
			&i.Sports,
			&i.Country,
			&i.Level,
			&i.StartTimestamp,
			&i.StatusCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentsByLevel = `-- name: GetTournamentsByLevel :many
SELECT id, tournament_name, slug, sports, country, level, start_timestamp, status_code FROM tournaments
WHERE sports=$1 AND level=$2
`

type GetTournamentsByLevelParams struct {
	Sports string `json:"sports"`
	Level  string `json:"level"`
}

func (q *Queries) GetTournamentsByLevel(ctx context.Context, arg GetTournamentsByLevelParams) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentsByLevel, arg.Sports, arg.Level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tournament
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.TournamentName,
			&i.Slug,
			&i.Sports,
			&i.Country,
			&i.Level,
			&i.StartTimestamp,
			&i.StatusCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentsBySport = `-- name: GetTournamentsBySport :many
SELECT id, tournament_name, slug, sports, country, level, start_timestamp, status_code FROM tournaments
WHERE sports=$1
`

func (q *Queries) GetTournamentsBySport(ctx context.Context, sports string) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentsBySport, sports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tournament
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.TournamentName,
			&i.Slug,
			&i.Sports,
			&i.Country,
			&i.Level,
			&i.StartTimestamp,
			&i.StatusCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newTournament = `-- name: NewTournament :one
INSERT INTO tournaments (
    tournament_name,
    slug,
    sports,
    country,
    level,
    start_timestamp,
    status_code
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, tournament_name, slug, sports, country, level, start_timestamp, status_code
`

type NewTournamentParams struct {
	TournamentName string          `json:"tournament_name"`
	Slug           string          `json:"slug"`
	Sports         string          `json:"sports"`
	Country        string          `json:"country"`
	Level          string          `json:"level"`
	StartTimestamp int64           `json:"start_timestamp"`
	StatusCode     json.RawMessage `json:"status_code"`
}

func (q *Queries) NewTournament(ctx context.Context, arg NewTournamentParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, newTournament,
		arg.TournamentName,
		arg.Slug,
		arg.Sports,
		arg.Country,
		arg.Level,
		arg.StartTimestamp,
		arg.StatusCode,
	)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.TournamentName,
		&i.Slug,
		&i.Sports,
		&i.Country,
		&i.Level,
		&i.StartTimestamp,
		&i.StatusCode,
	)
	return i, err
}

const updateTournamentDate = `-- name: UpdateTournamentDate :one
UPDATE tournaments
SET start_timestamp=$1
WHERE id=$2
RETURNING id, tournament_name, slug, sports, country, level, start_timestamp, status_code
`

type UpdateTournamentDateParams struct {
	StartTimestamp int64 `json:"start_timestamp"`
	ID             int64 `json:"id"`
}

func (q *Queries) UpdateTournamentDate(ctx context.Context, arg UpdateTournamentDateParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentDate, arg.StartTimestamp, arg.ID)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.TournamentName,
		&i.Slug,
		&i.Sports,
		&i.Country,
		&i.Level,
		&i.StartTimestamp,
		&i.StatusCode,
	)
	return i, err
}
